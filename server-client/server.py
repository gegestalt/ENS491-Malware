import threading, socket, sys
import logging
import multiprocessing
from watchdog.observers import Observer
from watchdog.events import LoggingEventHandler
import time 

event_handler = LoggingEventHandler()
observer = Observer()

folder = "/workspace/ENS491-Malware/server-client"
def monitor_folder(folder):
    logging.basicConfig(level=logging.INFO,
                        format='[*] %(asctime)s - %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')

    observer.schedule(event_handler, folder, recursive=True)
    observer.start()

    try:
        while True:
            # Set the thread sleep time
            time.sleep(5)
    except KeyboardInterrupt:
        observer.stop()
    time.sleep(5)
    observer.join()



ip = "0.0.0.0"
port = 1234


class handle_client(threading.Thread) :
    def __init__(self, client_socket, client_address) :
        super(handle_client, self).__init__()
        
        self.csock = client_socket
        # addr is just to keep track of clients from the output
        self.addr = client_address
        print("[+]:Initialised the handler thread for %s:%s connection" % (self.addr[0], self.addr[1]))
        
        request = self.csock.recv(1024)
        print(f'[*] Received: {request.decode("utf-8")}')
        self.csock.send(b'[ACK]')
        return

    def run(self):
        print("[+] Server:started the handler thread for %s:%s connection" % (self.addr[0], self.addr[1]))
        
        recvbuf = "Empty"
        msg = None

        while True:
            
            recvbuf = None
            try:
                
                recvbuf = self.csock.recv(1024)
           
            except (OSError, ConnectionResetError, ConnectionAbortedError, ConnectionError) as err:
                print("$ %s:%s recv() failed with error: %s" % (self.addr[0], self.addr[1], err))
                break
            except:
                print("$ %s:%s recv() failed with unexpected error: %s" % (self.addr[0], self.addr[1], sys.exc_info() [0]))
                break

      
            if len(recvbuf) != 0:
                
                msg = recvbuf.decode()
                print("\n> Message received from %s:%s (length=%d):\n%s" % (self.addr[0], self.addr[1], len(recvbuf),msg))

                try:
                   
                    self.csock.sendall(bytes(msg, 'utf8'))
                
                except (OSError, ConnectionResetError, ConnectionAbortedError, ConnectionError) as err:
                    print("$ %s:%s sendall() failed with error: %s" % (self.addr[0], self.addr[1], err))
                    break
                except:
                    print("$ %s:%s sendall() failed with unexpected error: %s" % (self.addr[0], self.addr[1], sys.exc_info() [0]))
                    break


                print("> Message received from %s:%s echoed back" % (self.addr[0], self.addr[1]))
                
            else:
                print("$ empty message received from %s:%s\n"% (self.addr[0], self.addr[1]))
                break

        print("[+] Closing connection with %s:%s..." % (self.addr[0], self.addr[1]))
        print(f"[ACTIVE CONNECTIONS] {threading.activeCount()-2}")

        try:
            
            self.csock.close()
        except OSError as err:
            print("$ close() failed with error: %s" % err)

        
        return


def main():
    m = multiprocessing.Process(target=monitor_folder, args=(folder,))
    m.start()
    s = None
    for res in socket.getaddrinfo(ip, port, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_PASSIVE):
        af, socktype, proto, canoname, sa = res
        try:
            s = socket.socket(af, socktype, proto)
            print("[*]:Socket created succefully.")
        except socket.error as err:
            print("$ socket():Socket creation failed with error %s" % err)
            s = None
            continue
        
        try:
           
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        except OSError as err:
            print("$ setsockopt():Setting option SO_REUSEADDR failed with error: %s" % err)
            s = None
            sys.exit(1)

        try:
            s.bind(sa)
            print("[*]:Socket binded to port %s" % port)
        except OSError as err:
            print("$ bind():\tBinding to port %d failed with error: %s" % (sa.port, err))
            s = None
            continue

        try:
            s.listen(5)
            print("[*]:Listening on port %s" % port)
            print(f"[ACTIVE CONNECTIONS] {threading.activeCount()-1}")

        except OSError as err:
            print("$ listen():Listening on port %d failed with error: %s" % (sa.port, err))
            s = None
            continue

        
        break

    
    if s is None:
        print("$ Could't open socket")
        sys.exit(1)

    
    client_handler = None
    while True:
        client, addr = s.accept()
        print("[+]:Accepted connection from %s:%d" % (addr[0], addr[1]))

        client_handler = handle_client(client, addr)
        client_handler.start()
        print(f"[ACTIVE CONNECTIONS] {threading.activeCount()-1}")
        
main()