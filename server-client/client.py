import socket, sys


# optional cleanup and exit function, another stupid idea from me ^_-
def gateway_out(sock):
    print("[*]gateway_out():\nConnection closing...\n\tProgam closing...")
    if sock is not None:
        try:
            sock.shutdown(socket.SHUT_RDWR)
        except OSError as err:
            print("[*]:shutdown() failed with error: %s" % err)

        try:
            sock.close()
        except OSError as err:
            print("[*] gateway_out(): close() failed with error: %s" % err)

    sys.exit(0)

# This function I made to put the data user inputs in a form to send.
# We don't use it if the user didn't gave any data (message, input).
def message_creator(msg):
    message = '''================================================
Start of the message:
%s
End of the message.
================================================''' % msg
    return message

def main(argv):
    target_ip = "127.0.0.1"
    target_port = int(3333)
                         
    for res in socket.getaddrinfo(target_ip, target_port, socket.AF_UNSPEC, socket.SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        try:
            s = socket.socket(af, socktype, proto)
            print("[*]:Socket created succefully.")
        except OSError as err:
            print(">:Socket creation failed with error %s" % err)
            s = None
            # not a critical failure, so move on test the next one
            continue
        
        
        try:
            # try connect to the target server [sa is tuple containing (target_ip, targt_port)]
            s.connect(sa)
            print("[*]:Connected to %s:%d" % (target_ip,target_port))
        # when accept fails it raises an OSError exception
        except OSError as err:
            print("[*]:Connection to server failed with error: %s" % err)
            s = None
            continue
        break

    
    if s is None:
        print("[*]Couldn't open socket")
        sys.exit(0)
    recvbuf = None
    sendbuf = message_creator(b"GET / HTTP/1.1\r\nHOST:google.com\r\n\r\n" )
    msg = None
    while True:
        try:
            # convert the message in the sendbuf to an byte abject to send it
            s.sendall(bytes(sendbuf, encoding="utf-8"))
        # handling exceptions
        except (OSError, ConnectionResetError, ConnectionAbortedError, ConnectionError) as err:
            print("$ sendall() failed with error: %s" % err)
            break
        except:
            print("$ sendall failed with an unexpected error")
            break

        try:
            # call recv() with 1024 as an argument to take data from the socket queue with a maximum size of 1024 bytes
            recvbuf = s.recv(1024)
        
        except (OSError, ConnectionResetError, ConnectionAbortedError, ConnectionError) as err:
            print("$ recv() failed with error: %s" % err)
            break
        except:
            print("$ recv() failed with an unexpected error")
            break

        if recvbuf == "" or recvbuf == None:
            print("$ Empt message received or connection closed")
            break

        # decode the received data from byte object to a string to print it as human readable in UTF-8 encoding by default
        msg = recvbuf.decode()
        print("\n> Message received from %s:\n%s" % (target_ip, msg))
        # Flush the received buffer for the next use
        recvbuf = None

        # let the user input the next message to be sent, check if it's empty or not, if so break the loop
        # and close the connection with server
        sendbuf = input("> Enter a message to send:")
        if len(sendbuf) == 0:
            break

        # put the (non empty message) in our form to be sent
        sendbuf = message_creator(sendbuf)

    print("Closing connection...\nClosing program...")
    s.close()
    sys.exit(0)

main(sys.argv)